<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AMG Cockpit – Luka Is The Beast</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    const canvas = document.getElementById("game");

    // --- Renderer / Scene / Camera ---
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05070b);

    const camera = new THREE.PerspectiveCamera(
      72,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.45);
    scene.add(ambient);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(15, 25, -10);
    scene.add(dirLight);

    // --- World: Road / Lanes / Guardrails ---
    const roadWidth = 14;
    const roadLength = 400;
    const roadGeo = new THREE.PlaneGeometry(roadWidth, roadLength, 1, 40);
    const roadMat = new THREE.MeshStandardMaterial({ color: 0x202020 });
    const road = new THREE.Mesh(roadGeo, roadMat);
    road.rotation.x = -Math.PI / 2;
    scene.add(road);

    // Lane lines
    const laneLines = new THREE.Group();
    const laneCount = 4;
    for (let i = -laneCount / 2 + 0.5; i < laneCount / 2; i++) {
      const lineGeo = new THREE.PlaneGeometry(0.15, roadLength, 1, 40);
      const lineMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
      });
      const line = new THREE.Mesh(lineGeo, lineMat);
      line.rotation.x = -Math.PI / 2;
      line.position.x = (roadWidth / laneCount) * i * 2;
      laneLines.add(line);
    }
    scene.add(laneLines);

    // Guardrails
    const railMat = new THREE.MeshStandardMaterial({
      color: 0x555555,
      metalness: 0.6,
      roughness: 0.3,
    });
    function createRail(xOffset) {
      const railGeo = new THREE.BoxGeometry(0.2, 1, roadLength);
      const rail = new THREE.Mesh(railGeo, railMat);
      rail.position.set(xOffset, 0.5, 0);
      return rail;
    }
    scene.add(createRail(roadWidth / 2 + 0.7));
    scene.add(createRail(-roadWidth / 2 - 0.7));

    // --- Car / Cockpit ---
    const car = new THREE.Group();

    // Car body (external shell)
    const bodyGeo = new THREE.BoxGeometry(2.0, 1.2, 4.6);
    const bodyMat = new THREE.MeshStandardMaterial({
      color: 0x111111,
      metalness: 0.5,
      roughness: 0.5,
    });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.6;
    car.add(body);

    // Cockpit shell
    const cockpitShellGeo = new THREE.BoxGeometry(2.2, 1.5, 2.6);
    const cockpitShellMat = new THREE.MeshStandardMaterial({
      color: 0x050608,
      metalness: 0.2,
      roughness: 0.8,
    });
    const cockpitShell = new THREE.Mesh(cockpitShellGeo, cockpitShellMat);
    cockpitShell.position.set(0, 1.1, 0.1);
    car.add(cockpitShell);

    // Dashboard top
    const dashGeo = new THREE.BoxGeometry(2.4, 0.25, 0.7);
    const dashMat = new THREE.MeshStandardMaterial({
      color: 0x05070b,
      metalness: 0.3,
      roughness: 0.7,
    });
    const dash = new THREE.Mesh(dashGeo, dashMat);
    dash.position.set(0, 1.35, 0.45);
    car.add(dash);

    // Instrument cluster housing
    const clusterGeo = new THREE.BoxGeometry(1.5, 0.55, 0.12);
    const clusterMat = new THREE.MeshStandardMaterial({
      color: 0x11141c,
      metalness: 0.3,
      roughness: 0.5,
      emissive: 0x05070b,
      emissiveIntensity: 0.9,
    });
    const cluster = new THREE.Mesh(clusterGeo, clusterMat);
    cluster.position.set(0, 1.37, 0.3);
    car.add(cluster);

    // Infotainment screen (3D plane with dynamic texture)
    const infoCanvas = document.createElement("canvas");
    infoCanvas.width = 512;
    infoCanvas.height = 256;
    const infoCtx = infoCanvas.getContext("2d");
    const infoTexture = new THREE.CanvasTexture(infoCanvas);
    infoTexture.encoding = THREE.sRGBEncoding;

    const infoGeo = new THREE.PlaneGeometry(0.95, 0.45);
    const infoMat = new THREE.MeshStandardMaterial({
      map: infoTexture,
      metalness: 0.6,
      roughness: 0.25,
      emissive: 0x111133,
      emissiveIntensity: 0.9,
    });
    const infoScreen = new THREE.Mesh(infoGeo, infoMat);
    infoScreen.position.set(0.75, 1.36, 0.38);
    infoScreen.rotation.y = -0.25;
    car.add(infoScreen);

    // Rearview mirror
    const mirrorGeo = new THREE.BoxGeometry(0.9, 0.2, 0.05);
    const mirrorMat = new THREE.MeshStandardMaterial({
      color: 0x111111,
      metalness: 0.9,
      roughness: 0.1,
    });
    const mirror = new THREE.Mesh(mirrorGeo, mirrorMat);
    mirror.position.set(0, 1.7, 0.1);
    car.add(mirror);

    // Seats
    const seatMat = new THREE.MeshStandardMaterial({
      color: 0x151515,
      metalness: 0.1,
      roughness: 0.8,
    });
    function createSeat(x) {
      const baseGeo = new THREE.BoxGeometry(0.6, 0.2, 0.6);
      const backGeo = new THREE.BoxGeometry(0.6, 0.8, 0.2);
      const base = new THREE.Mesh(baseGeo, seatMat);
      const back = new THREE.Mesh(backGeo, seatMat);
      base.position.set(x, 0.9, -0.3);
      back.position.set(x, 1.25, -0.05);
      const seat = new THREE.Group();
      seat.add(base);
      seat.add(back);
      return seat;
    }
    car.add(createSeat(-0.5));
    car.add(createSeat(0.5));

    // Steering wheel (AMG-ish: round with flat bottom + hub + spokes)
    const wheelOuterGeo = new THREE.TorusGeometry(0.45, 0.08, 20, 40);
    const wheelMat = new THREE.MeshStandardMaterial({
      color: 0x111111,
      metalness: 0.4,
      roughness: 0.4,
    });
    const steeringWheel = new THREE.Mesh(wheelOuterGeo, wheelMat);
    steeringWheel.rotation.z = Math.PI / 2;
    steeringWheel.position.set(0, 1.25, 0.7);
    car.add(steeringWheel);

    // Flat bottom
    const flatGeo = new THREE.BoxGeometry(0.7, 0.12, 0.09);
    const flat = new THREE.Mesh(flatGeo, wheelMat);
    flat.position.set(0, -0.35, 0);
    steeringWheel.add(flat);

    // Center hub
    const hubGeo = new THREE.CylinderGeometry(0.22, 0.22, 0.08, 32);
    const hubMat = new THREE.MeshStandardMaterial({
      color: 0x1b1f26,
      metalness: 0.6,
      roughness: 0.3,
    });
    const hub = new THREE.Mesh(hubGeo, hubMat);
    hub.rotation.x = Math.PI / 2;
    steeringWheel.add(hub);

    // Simple AMG-style "star" hint on hub
    const starMat = new THREE.LineBasicMaterial({ color: 0xc0c4cc });
    const starGeo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, 0.18, 0.05),
      new THREE.Vector3(0, -0.1, 0.05),
      new THREE.Vector3(0, 0, 0.05),
      new THREE.Vector3(-0.16, -0.05, 0.05),
      new THREE.Vector3(0, 0, 0.05),
      new THREE.Vector3(0.16, -0.05, 0.05),
    ]);
    const star = new THREE.LineSegments(starGeo, starMat);
    hub.add(star);

    // Turn signal indicators on cluster
    const signalMatOff = new THREE.MeshStandardMaterial({
      color: 0x333333,
      emissive: 0x000000,
    });
    const signalMatOn = new THREE.MeshStandardMaterial({
      color: 0xffaa00,
      emissive: 0xffaa00,
      emissiveIntensity: 1.5,
    });
    const leftSignalMesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.04, 16, 16),
      signalMatOff.clone()
    );
    leftSignalMesh.position.set(-0.45, 1.42, 0.32);
    car.add(leftSignalMesh);

    const rightSignalMesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.04, 16, 16),
      signalMatOff.clone()
    );
    rightSignalMesh.position.set(0.45, 1.42, 0.32);
    car.add(rightSignalMesh);

    // Camera rig (fixed cockpit view with road feel)
    const cameraRig = new THREE.Group();
    cameraRig.position.set(0, 1.25, 0.05); // driver head position
    camera.position.set(0, 0, 0);
    cameraRig.add(camera);
    car.add(cameraRig);

    // Place car
    car.position.set(0, 0, 0);
    scene.add(car);

    // --- Traffic ---
    const traffic = [];
    const trafficMat = new THREE.MeshStandardMaterial({
      color: 0xff3333,
      metalness: 0.4,
      roughness: 0.5,
    });

    function spawnTrafficCar() {
      const geo = new THREE.BoxGeometry(1.8, 1.2, 4);
      const mesh = new THREE.Mesh(geo, trafficMat.clone());
      const laneIndex = Math.floor(Math.random() * laneCount);
      const laneX = (laneIndex - (laneCount - 1) / 2) * (roadWidth / laneCount);
      mesh.position.set(laneX, 0.6, car.position.z - 80 - Math.random() * 150);
      mesh.userData.speed = 70 + Math.random() * 80; // km/h
      scene.add(mesh);
      traffic.push(mesh);
    }

    for (let i = 0; i < 10; i++) spawnTrafficCar();

    // --- Input / State ---
    const keys = {};
    document.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
    });
    document.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    let speed = 0; // km/h
    let rpm = 800;
    let gearIndex = 0;
    const gears = ["P", "R", "N", "D"];
    let modeIndex = 0;
    const modes = ["Comfort", "Sport", "Sport+"];

    let steeringInput = 0; // -1..1
    let steeringAngle = 0; // radians
    let leftSignal = false;
    let rightSignal = false;
    let signalBlink = false;
    let signalTimer = 0;

    let lastSpeed = 0;
    let hornCooldown = 0;

    // --- Update infotainment screen ---
    function updateInfotainment() {
      infoCtx.clearRect(0, 0, infoCanvas.width, infoCanvas.height);

      // Background
      const grad = infoCtx.createLinearGradient(0, 0, infoCanvas.width, infoCanvas.height);
      grad.addColorStop(0, "#050816");
      grad.addColorStop(1, "#111133");
      infoCtx.fillStyle = grad;
      infoCtx.fillRect(0, 0, infoCanvas.width, infoCanvas.height);

      // Header
      infoCtx.fillStyle = "#ff4040";
      infoCtx.font = "bold 32px system-ui";
      infoCtx.textAlign = "left";
      infoCtx.fillText("luka is the beast", 24, 46);

      // Performance data
      infoCtx.fillStyle = "#f5f7fb";
      infoCtx.font = "26px system-ui";
      infoCtx.fillText(`Speed: ${speed.toFixed(0)} km/h`, 24, 100);
      infoCtx.fillText(`RPM:   ${rpm.toFixed(0)}`, 24, 140);
      infoCtx.fillText(`Gear:  ${gears[gearIndex]}`, 24, 180);
      infoCtx.fillText(`Mode:  ${modes[modeIndex]}`, 24, 220);

      // Simple bar for speed
      const maxBarWidth = 220;
      const ratio = Math.min(1, Math.abs(speed) / 260);
      infoCtx.fillStyle = "#333a55";
      infoCtx.fillRect(infoCanvas.width - maxBarWidth - 40, 90, maxBarWidth, 20);
      infoCtx.fillStyle = "#4bff7a";
      infoCtx.fillRect(
        infoCanvas.width - maxBarWidth - 40,
        90,
        maxBarWidth * ratio,
        20
      );

      infoTexture.needsUpdate = true;
    }

    // --- Update ---
    let lastTime = performance.now();

    function update(dt) {
      // Gear change (G)
      if (keys["g"]) {
        gearIndex = (gearIndex + 1) % gears.length;
        keys["g"] = false;
      }
      const gear = gears[gearIndex];

      // Mode change (M)
      if (keys["m"]) {
        modeIndex = (modeIndex + 1) % modes.length;
        keys["m"] = false;
      }
      const mode = modes[modeIndex];

      // Horn (H)
      if (keys["h"] && hornCooldown <= 0) {
        console.log("HORN: BEEEEEP (add sound later)");
        hornCooldown = 0.3;
      }
      hornCooldown -= dt;

      // Throttle / brake based on gear
      let accelBase;
      let drag;
      if (mode === "Sport+") {
        accelBase = 150;
        drag = 0.32;
      } else if (mode === "Sport") {
        accelBase = 120;
        drag = 0.34;
      } else {
        accelBase = 95;
        drag = 0.38;
      }

      let accel = 0;

      if (gear === "D") {
        if (keys["w"]) accel += accelBase;
        if (keys["s"]) accel -= 220;
      } else if (gear === "R") {
        if (keys["w"]) accel -= accelBase * 0.7;
        if (keys["s"]) accel += 220;
      } else {
        if (keys["s"]) accel -= 220;
      }

      speed += accel * dt;
      speed -= speed * drag * dt;
      speed = Math.max(-40, Math.min(260, speed));

      // RPM
      rpm = 900 + Math.abs(speed) * 40 + (keys["w"] ? 700 : 0);
      rpm = Math.min(7800, rpm);

      // Steering input (A = left, D = right)
      if (keys["a"]) steeringInput += 3 * dt;
      if (keys["d"]) steeringInput -= 3 * dt;
      steeringInput = Math.max(-1, Math.min(1, steeringInput));
      steeringInput *= 0.9;

      // Speed‑sensitive steering
      const steeringStrength = THREE.MathUtils.lerp(
        1.8,
        0.4,
        Math.min(1, Math.abs(speed) / 220)
      );
      const yawDelta = steeringInput * steeringStrength * dt;

      // Move car forward/back along local -Z
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(car.quaternion);
      const distance = (speed / 3.6) * dt;
      car.position.addScaledVector(forward, distance);

      // Rotate car around Y
      car.rotation.y += yawDelta;

      // Steering wheel rotation
      steeringAngle = steeringInput * 0.9;
      steeringWheel.rotation.y = steeringAngle + Math.PI;

      // Road reposition (loop under car)
      const carZ = car.position.z;
      road.position.z = carZ - 50;
      laneLines.position.z = road.position.z;

      // Traffic update
      for (const t of traffic) {
        const relSpeed = t.userData.speed - speed;
        const dz = (relSpeed / 3.6) * dt;
        t.position.z += dz;

        if (t.position.z > carZ + 60) {
          const laneIndex = Math.floor(Math.random() * laneCount);
          const laneX =
            (laneIndex - (laneCount - 1) / 2) * (roadWidth / laneCount);
          t.position.set(laneX, 0.6, carZ - 120 - Math.random() * 150);
          t.userData.speed = 70 + Math.random() * 80;
        }
      }

      // Signals
      if (keys["z"]) {
        leftSignal = true;
        rightSignal = false;
      }
      if (keys["x"]) {
        rightSignal = true;
        leftSignal = false;
      }
      if (keys["z"] && keys["x"]) {
        leftSignal = false;
        rightSignal = false;
      }

      signalTimer += dt;
      if (signalTimer > 0.5) {
        signalTimer = 0;
        signalBlink = !signalBlink;
      }

      leftSignalMesh.material =
        leftSignal && signalBlink ? signalMatOn : signalMatOff;
      rightSignalMesh.material =
        rightSignal && signalBlink ? signalMatOn : signalMatOff;

      // Road feel: weight transfer + subtle shake
      const accelNow = (speed - lastSpeed) / dt;
      lastSpeed = speed;

      const accelNorm = THREE.MathUtils.clamp(accelNow / 220, -1, 1);
      const steerNorm = steeringInput;

      const pitch = THREE.MathUtils.lerp(
        cameraRig.rotation.x,
        accelNorm * -0.06,
        0.15
      );
      const roll = THREE.MathUtils.lerp(
        cameraRig.rotation.z,
        steerNorm * -0.04,
        0.15
      );

      const t = performance.now() / 1000;
      const vib = (rpm / 7800) * 0.002;
      const shakeX = Math.sin(t * 40) * vib;
      const shakeY = Math.cos(t * 35) * vib;

      cameraRig.rotation.x = pitch + shakeY;
      cameraRig.rotation.z = roll + shakeX;

      // FOV change with speed
      const baseFov = 72;
      const maxFov = 92;
      const speedRatio = THREE.MathUtils.clamp(Math.abs(speed) / 220, 0, 1);
      camera.fov = THREE.MathUtils.lerp(baseFov, maxFov, speedRatio * 0.7);
      camera.updateProjectionMatrix();

      // Make sure camera looks forward over the wheel
      const lookTarget = new THREE.Vector3(0, 1.35, 3);
      car.localToWorld(lookTarget);
      camera.lookAt(lookTarget);

      // Update infotainment
      updateInfotainment();
    }

    // --- Loop ---
    function animate(now) {
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;

      update(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    let lastTime = performance.now();
    requestAnimationFrame(animate);

    // Resize
    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
